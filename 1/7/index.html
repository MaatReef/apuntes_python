<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Introducción Python</title>
    <link rel="shortcut icon" type=image/jpg href="../../img/logo/favicon.ico"/>
    <link href="https://fonts.googleapis.com/css2?family=Carrois+Gothic+SC&display=swap" rel="stylesheet"> 
    <link rel="stylesheet" href="css/style.css">

</head>
<body>
    <div class="context">
        <a href="../6/index.html">Volver</a>
        <a href="../../index.html">Inicio</a>
        <a href="../8/index.html">Siguiente</a>
    </div>
    <div class="contenido" id="arriba">
        <p>Python - Notas</p>
    </div>

    <h1>7 - Programa una Cuenta Bancaria.</h1>
    <ol>
        <li><a href="#1">Méta del Día 7</a></li>  
        <li><a href="#2">Programación Orientada a Objetos</a></li>
        <li><a href="#3">Clases</a></li>
        <li><a href="#4">Atributos</a></li>
        <li><a href="#5">Metodos</a></li>
        <li><a href="#6">Tipos de Métodos</a></li>
        <li><a href="#7">Herencia</a></li>
        <li><a href="#8">Herencia Extendida</a></li>
        <li><a href="#9">Polimorfismo</a></li>
        <li><a href="#10">Métodos Especiales</a></li>
        <li><a href="#11">Proyecto del Día 7</a></li>
        <li><a href="#12">Solución al Proyecto del Día 7</a></li>
    </ol>

    <p id="1">1. Meta del Día 7)</p>
    <pre>
        Programar una Cuenta bancaria, capa de retener un balance de cuenta, recibir depósitos y permitir los retiros.	

        Aprender, POO.. Programación Orientada a Objetos.
        -Razón por la cual escribir código en Python es tan fácil.
        --------------------------------------------------------
    </pre>
    <div class="context">
        <a href="#arriba">Arriba</a>
    </div>
    <p id="2">2. Programación Orientada a Objetos</p>
    <pre>
        POO
        O bien OOP	-> Object Oriented Programing.
        
        Es un modo de programación que permite organizar el código, a una manera que se asemeja bastante a como pensamos en la vida real.
        Diseñando objetos digitales, a los que podemos crear, manipular o destruir.
        
        El código que define a un objeto, lo llamamos Clase.
        - Las clases permiten agrupar un conjunto de variables y funciones para que nuestros objetos tengan vida.
        - Todo lo que se pueda plasmar en código desde la vida cotidiana, puede representarse en una clase.
        - Una silla, un edificio, un pájaro..
        
        Ej con el Pájaro.. Definiremos un conjunto de sus características.
        - Color		----|
        - Tipo		    |
        - Hábitat	    |	-> ATRIBUTOS.
        - Edad		    |
        - Tamaño	----|
        
        
        Además las clases tiene un conjunto de Funcionalidades, o cosas que pueden hacer.
        Ejemplo del pájaro.
        - Volar		----|
        - Comer		    |	-> MÉTODOS
        - Piar		----|
        
        Además podemos representar un conjunto de pájaros, cada uno de ellos, es uno distinto, que desde el programa pueden crearse, desde el objeto pájaro.
        Ejemplo, diversos pájaros con diferentes nombres, Twitty, Pepe.
        - Estos diversos pájaros serán los 	-> OBJETOS
        Es decir, el concepto abstracto de pájaro, es la clase.
        Pero cada pájaro en particular es un OBJETO, una instancia de esa clase, cada instancia por lo tanto, será un considerada como un OBJETO.	
        
        Ahora..
        - Crear Clases.
        - Definir Atributos.
        - Definir Métodos.
        - Crear Objetos.
        
        Considerar entonces que la POO es un modo de Programación y que no todos los Lenguajes de Programación, soportan la POO.
        
        La progrmación Orientada a Objetos, está basada en 6 Principios o Pilares Básicos.
        - Herencia
        - Polimorfismo
        - Cohesión
        - Abstracción
        - Acoplamiento
        - Encapsulamiento
        
        
        --------------------------------------------------------
        ¿Por qué POO?
        Antes de que exista, para programamar eventos, se utilizaban Funciones.
        Permiten agrupar bloque de código, bajo un determinado nombre, para que hagan un tarea específica.	
        
        Las funciones eran útiles, pero el problema es que éstas solo hacen unas funciones determinadas con datos de entradas para entregar una salida.
        Pero no interesando tanto, el hecho de conservar esos datos, o mantener un tipo de estado.
        
        Esto lo soluciona el Objeto, conservando diferentes ATRIBUTOS de un Objeto en particular..
        De lo contrario tendríamos muchisimas variables sueltas que usarían las funciones.
        Y el problema serìa tener muchisimos objetos, con otros muchisimos atributos, por lo cual la CLASE lo resuelve, agrupando el conjunto de atributos..
        Facilitando la Instancia en diversos OBJETOS, los que sean necesarios.
        
        Más sencillo, más organizado..
        Agrupamos dentro una CLASE un conjunto de Variables, atributos y métodos.
        Que pueden ser re utilizados, que son faciles de mantener y utilizar, y son flexibles para diversos usos.
        --------------------------------------------------------        
    </pre>
    <div class="context">
        <a href="#arriba">Arriba</a>
    </div>
    <p id="3">3. Clases</p>
    <pre>
        class Pajaro:				-> Por convención, el nombre de la clase se escribe comenzando con Mayúscula.

        class ElementoPajaro:			-> Sin espacios, en mayúsculas cada palabra.
        
        
        class Pajaro:				
            pass				-> Clase mínima (con pass, para evitar el error)
        
        
        mi_pajaro = Pajaro()			-> Instanciamos un objeto de la clase pájaro, como si fuera una variable normal.
                            -> En este caso () van vacíos, pero pueden requerir argumentos, para ser creada.
        
        --------------------------------------------------------
        
        class Pajaro:				-> Definición de un concepto de Abstracto.
            pass
        
        
        mi_pajaro = Pajaro()			-> Instancia de clase Pajaro
                            -> El objeto, es un tipo de dato nuevo, como los es int, bool, pero en este caso, un pajaro.
        
        otro_pajaro = Pajaro()
        
        print(mi_pajaro)			-> < __main__.Pajaro object at 0x0000001213asdkl23>	-> Objeto distinto
        print(otro_pajaro)			-> < __main__.Pajaro object at 0x0000001213asdsd1a>	-> Objeto distinto
        
        print(type(mi_pajaro))			-> < class '__main__.Pajaro'>		-> Es decir, ni string, ni diccionario, es un PAJARO
                                                -> Es un tipo de dato.
        
        --------------------------------------------------------        
    </pre>
    <br>
    <img src="img/3.1 Clases.png" alt="">
    <br>
    <p class="practica">Practica</p>
    <pre>
        Práctica Clases 1
        Crea una clase llamada Personaje y a continuación, crea un objeto a partir de ella, por ejemplo: harry_potter
        
        class Personaje:
          pass
        
        harry_potter = Personaje()
        
        print(type(harry_potter))
        print(harry_potter)
                        -> < class '__main__.Personaje'>
                        -> < __main__.Personaje object at 0x7f2bf42095b0>
        
        --------------------------------------------------------
        Práctica Clases 2
        Crea una clase llamada Dinosaurio, y tres instancias a partir de ella: velociraptor, tiranousaurio_rex y braquiosaurio .
        
        class Dinosaurio:
          pass
        
        velociraptor = Dinosaurio()
        tiranosaurio_rex = Dinosaurio()
        braquiosaurio = Dinosaurio()
        --------------------------------------------------------
        Práctica Clases 3
        Crea una clase llamada PlataformaStreaming y crea los siguientes objetos a partir de ella: netflix, hbo_max, amazon_prime_video
        
        class PlataformaStreaming:
          pass
        
        netflix = PlataformaStreaming()
        hbo_max = PlataformaStreaming()
        amazon_prime_video = PlataformaStreaing()
        
        --------------------------------------------------------        
    </pre>
    <div class="context">
        <a href="#arriba">Arriba</a>
    </div>
    <p id="4">4. Atributos</p>
    <pre>
        Existen dos tipos de Atributos.
        -> De clase: Los que pertenecen a la Clase, serán los mismos para todos los objetos que vayan a ser creados desde esta clase. 
                .Ejemplo.
            alas = True		-> Todos los objetos pájaros tomarán el atributos de alas = True
    
        -> De instancia: Estos pertenecen a la instancia de la clase o al objeto, particulares, pudiendo ser distintos en cada instancia.
                .Ejemplo.
            color = 'negro'		-> Es decir, cada pajaro (objeto) instanciado particularmente tendrà su respectivo color.
            color = 'marron'
    
    --------------------------------------------------------
    
    class Pajaro:					-> Creamos la clase
    
        def __init__(self, color):		-> Definimos el método constructor, que asignará atributos a la clase Pajaro
            self.color = color		-> self, es obligatorio, refiere a "el mismo", más el atributo color.
                            -> self es la instancia del objeto que se va a crear, asignandole el parámetro color.
    
    
    mi_pajaro = Pajaro('negro')			-> Ahora le pasamos el argumento, estamos "obligados"
    
    
    print(mi_pajaro.color)				-> negro
                            -> mi_pajaro.color, es decir, creamos un método para el objeto..
                            -> Como lo es con upper, lower, los métodos de strings, entre otros..
    
    --------------------------------------------------------
    
    class Pajaro:					
                            -> __init__ es un método, serìa el constructor de la clase.. 
        def __init__(self, color):		-> cada vez que creamos una clase, python llama a su constructor para ver los requisitos de la clase,
            self.color = color		-> Que atributos necesita, para que el objeto se pueda construir adecuadamente.
            
                -> Self, representa la instancia del objeto que vaya a ser creado, (por CONVENCIÓN se usa self, se puede usar otra palabra)			
    
                
    
    
    mi_pajaro = Pajaro('negro')			-> Por lo tanto, al crear la instancia de pájaro, debemos pasarle el valor, de la construcción anteirior..
                            -> si o si, el sistema se fija a través de init, que es lo que se requiere.
    
    print(mi_pajaro.color)				
    
    --------------------------------------------------------
    
    class Pajaro:					
                         
        def __init__(self, mi_parametro):	
            self.atributo = mi_parametro	
                
                -> Por lo tanto el atributo self debe llenarse con un parámetro, el parametro lo pasamo abajo.
    
    mi_pajaro = Pajaro('negro')			
    
    print(mi_pajaro.atributo)				
    
    --------------------------------------------------------
    
    class Pajaro:					
                         
        def __init__(self, color):	-> 1º Por lo tanto, pasamos un parametro color.
            self.color = color	-> 3ª parametro color que le pasemos la instancia de nuestro objeto.
                -> 2ª El atributo color, debe ser igual al..
                
                        *Por convención, el parámetro y el atributo deben llevar el mismo nombre.
                        -Lógica y Uso, más sencillo.
    mi_pajaro = Pajaro('negro')			
    
    print(mi_pajaro.atributo)				
    
    --------------------------------------------------------
                -> Agregando màs atributos  
                -> Por lo tanto tendremos un atributo de INSTANCIA, porque es un atributo donde cada objeto, puede tener un valor distinto.
                -> Pajaro 1, puede ser negro, otros halcones, etc..
                -> Mientras que los de CLASE son iguales para todos los objetos instanciados, desde pájaro.
    class Pajaro:					
                         
        def __init__(self, color, especie):	
            self.color = color	
            self.especie = especie
                
                
    mi_pajaro = Pajaro('negro', 'Pelicano')			
    
    print(mi_pajaro.color)			-> Negro
    print(mi_pajaro.especie)		-> Pelicano
    
    print(f'Mi pajaro es un {mi_pajaro.especie} y es de color {mi_pajaro.color}')
    
    --------------------------------------------------------
                    -> Atributos de clases por lo tanto.
    class Pajaro:					
                         
        alas = true					-> 		
    
        def __init__(self, color, especie):	
            self.color = color	
            self.especie = especie
                
                
    mi_pajaro = Pajaro('negro', 'Pelicano')			
    
    
    print(Pajaro.alas)		-> True		-> Lo consultamos desde la clase, todos lo tendrán, todos los objetos comparten el atributo de clase.
    print(mi_pajaro.alas)		-> True		-> Lo consultamos desde el objeto instanciado, que también lo tendrá
    
    --------------------------------------------------------        
    </pre>
    <br>
    <img src="img/4.1 Atributos.png" alt="">
    <br>
    <p class="practica">Práctica</p>
    <pre>
        --------------------------------------------------------
        Práctica Atributos 1
        Crea una clase llamada Casa, y asígnale atributos: color, cantidad_pisos.
        
        Crea una instancia de Casa, llamada casa_blanca, de color "blanco" y cantidad de pisos igual a 4
        
        class Casa:
            
            def __init__(self, color, cantidad_pisos):
                self.color = color
                self.cantidad_pisos = cantidad_pisos
        
        casa_blanca = Casa('blanco', '4')
        
        print(casa_blanca.color)
        
        print(f'Mi Casa es de color {casa_blanca.color} y tiene un total de {casa_blanca.cantidad_pisos} pisos.')
        
                        -> blanco
                        -> Mi casa es de color blanco y tiene un total de 4 pisos.
        --------------------------------------------------------
        
        Práctica Atributos 2
        Crea una clase llamada Cubo, y asígnale el atributo de clase:
        
        caras = 6
        
        y el atributo de instancia:
        
        color
        
        Crea una instancia cubo_rojo, de dicho color.
        
        class Cubo:
        
            caras = 6
        
            def __init__(self, color):
                self.color = color
        
        cubo_rojo = Cubo('Rojo')
        
        print(cubo_rojo.color)
        print(f'El cubo que cree es de color {cubo_rojo.color} y tiene un total de {Cubo.caras} caras.')
        
                    -> Rojo
                    -> El cubo que cree es de color rojo y tiene un total de 6 caras.
        
        
        --------------------------------------------------------
        
        Práctica Atributos 3
        Crea una clase llamada Personaje, y asígnale el siguiente atributo de clase:
        
        real = False
        
        Crea una instancia llamada harry_potter con los siguientes atributos de instancia:
        
        especie = "Humano"
        
        magico = True
        
        edad = 17
        
        class Personaje:
        
            real = False
        
            def __init__(self, especie, magico, edad):
                self.especie = especie
                self.magico = magico
                self.edad = edad
        
        harry_potter = Personaje ('Humano', 'True', '17')
        
        print(f'El personaje de Harry Potter es de especie {harry_potter.especie} con una edad de {harry_potter.edad}.')
        
            -> El personaje de Harry Potter es de especie Humano con una edad de 17.
        --------------------------------------------------------        
    </pre>
    <div class="context">
        <a href="#arriba">Arriba</a>
    </div>
    <p id="5">5. Metodos</p>
    <pre>
        Técnicamente __init__ es un método, es uno especial, incorporado a todas las clases por defecto.

        class Pajaro:
        
            def __init__(self,color,especie):
                self.color = color
                self.especie = especie
        
            def piar(self):				-> Le pasamos obligatoriamente self, que hace referencia a cada instancia o bien objeto, de esa clase.
                print("Pío")		-> Para que el pajaro pie
        
        
            def volar(self, metros):
                print(f"Volò {metros} mts")		-> Para ejecutarlo..
        
        --------------------------------------------------------
        
        class Pajaro:
        
            alas = True
        
            def __init__(self, color, especie):
                self.color = color
                self.especie = especie
        
            def piar(self):						-> self es obligatorio
                print("Pío")
        
            def volar(self, metros):
                print(f"El pajaro ha volado una cantidad de {metros} metros")
        
        piolin = Pajaro('amarillo', 'canario')
        
        piolin.piar()					-> pio
        
        piolin.volar(50)				-> El pajaro ha volado 50 metros
        
            
        --------------------------------------------------------
        
        class Pajaro:
        
            alas = True
        
            def __init__(self, color, especie):
                self.color = color
                self.especie = especie
        
            def piar(self):						
                print('Pío, mi color es {}'.format(self.color))				-> Recordar, self.color
                                            -> Cada vez que se construya un metodo dentro de la clase que invoque un atributo
                                            -> Necesitamos relacionar a quien pertence el atributo, self -> al objeto/instancia..
                                            -> Que está invocando a esa instancia.
            def volar(self, metros):
                print(f"El pajaro ha volado una cantidad de {metros} metros")
        
        piolin = Pajaro('amarillo', 'canario')
        
        piolin.piar()					-> pio, mi color es amarillo
        
        --------------------------------------------------------        
    </pre>
    <br>
    <img src="img/5.1 Métodos.png" alt="">
    <br>
    <p class="practica">Práctica</p>
    <pre>
        --------------------------------------------------------
        Práctica Métodos 1
        Crea una clase Perro. Dicho perro debe poder ladrar.
        
        Crea el método ladrar() y ejecútalo en una instancia de Perro. Cada vez que ladre, debe mostrarse en pantalla "Guau!".
        
        class Perro:
        
            def ladrar(self):
                print('Guau')
        
        dogo = Perro()
        
        dogo.ladrar()			-> Guau
        
        --------------------------------------------------------
        
        Práctica Métodos 2
        Crea una clase llamada Mago, y crea un método llamado lanzar_hechizo() (deberá imprimir "¡Abracadabra!").
        
        Crea una instancia de Mago en el objeto merlin, y haz que lance un hecizo.
        
        class Mago:
            
            def lanzar_hechizo(self):
                print('¡Abracadabra!')
        
        merlin = Mago()
        
        merlin.lanzar_hechizo()			-> ¡Abracadabra!
        
        --------------------------------------------------------
        
        Práctica Métodos 3
        Crea una instancia de la clase Alarma, que tenga un método llamado postergar(cantidad_minutos). El método debe imprimir en pantalla el mensaje
        
        "La alarma ha sido pospuesta {cantidad_minutos} minutos"
        
        
        class Alarma:
        
            def postergar(self, cantidad_minutos):
                print(f'La alarma ha sido propuesta {cantidad_minutos} minutos.')
        
        
        alarma = Alarma()
        
        alarma.postergar(50)		-> La alarma ha sido propuesta 50 minutos.
        
        
        --------------------------------------------------------        
    </pre>
    <div class="context">
        <a href="#arriba">Arriba</a>
    </div>
    <p id="6">6. Tipos de Métodos</p>
    <pre>
        Decoradores	-> Permiten crear diferentes tipos de métodos.

        - métodos de instancia		-> Los que venimos haciendo
    Una vez creados, pueden ser llamados, pueden además..
    -Acceder y modificar atributos del objeto.
    -Acceder a otros métodos
    -Modificar el estado de la clase
    
    Ej.. 
    def mi_metodo(self):
        print("algo")
    
    mi_meotod()
    
    
        - métodos de clase		-> @classmethod, metodo de clase
    Este método no están asociados a las instancias de nuestra clase, sino a la clase en sí misma..
    Por lo tanto pueden ser llamados desde una instancia de nuestra clase, sino también directamente desde la clase.	
    -No pueden acceder a los atributos de instancia.
    -Si pueden modificar los aributos de la clase.
    
    Ej..
    @classmethod
    def mi_metodo(cls):			-> cls de clase
        print("algo")
    
        - métodos estáticos		-> @staticmethod, método estático
    Por lo tanto..
    -No pueden modificar el estado de la clase, ni de la instancia..
    -Pero pueden aceptar parámetros de entrada.
    -Util para indicar que un método no podrá modificar el estado de la instancia ni de la clase.
    Funciones normales, que si van ligadas a una clase concreta.
    
    Ej..
    @staticmethod
    def mi_metodo():			-> No aceptan como parámetro, ni self ni cls
        print("algo")
    
    --------------------------------------------------------
                            -> Métodos de Instancia.
    class Pajaro:
    
        alas = True
    
        def __init__(self, color, especie):		--> Métodos de instancia, afectan al self, ACCEDEN Y MODIFICAN los atributos del objeto
            self.color = color
            self.especie = especie
    
        def piar(self):
            print('pio')
    
        def volar(self, metros):				
            print(f"El pajaro vuela {metros} metros")	
            self.piar()					-> Permiten acceder a otros métodos
    
        def pintar_negro(self):
            self.color = 'negro'
            print(f"Ahora el pájaro es {self.color}")
    
    
    piolin = Pajar("amarillo", "canario")
    
    piolin.pintar_negro()				-> Ahora el pájaro es negro.
    
    piolin.volar(50)			-> El pajaro vuela 50 metros
                        -> pio
    
    piolin.alas = False
    print(piolin.alas)						->Permite MODIFICAR el estado de la clase.
    
    --------------------------------------------------------
            -> Métodos de clase
    
                -> Ahora vamos con el @classmethod
    
    class Pajaro:
    
        alas = True
    
        def __init__(self, color, especie):
            self.color = color
            self.especie = especie
    
        def piar(self):
            print('pio')
    
        def volar(self, metros):				
            print(f"El pajaro vuela {metros} metros")	
    
        @classmethod
        def poner_huevos(cls, cantidad):			-> No necesitan de una instancia para ejecutarse, son "independientes"
            print(f"Puso {cantidad} huevos")		-> No pueden acceder a los atributos de instancia, color y especie
            #print(f"Es de color {self.color}")	-> No se puede, no está el agumento self
    
            cls.alas = False		-> Podemos modificar la clase desde este método
            print(Pajaros.alas)		-> False	
    
    Pajaro.poner_huevos(3)		-> Puso 3 huevos
    
    Pajaro.piar()			-> No lo permite, ya que es un método de instancia y necesitaba un argumento posicional self, que no lo tiene.
    
    --------------------------------------------------------
                Metodos estaticos. 
    
    class Pajaro:
    
        alas = True
    
        def __init__(self, color, especie):
            self.color = color
            self.especie = especie
    
        def piar(self):
            print('pio')
    
        def volar(self, metros):				
            print(f"El pajaro vuela {metros} metros")	
    
        @classmethod
        def poner_huevos(cls, cantidad):			
            print(f"Puso {cantidad} huevos")	
            cls.alas = False		
            print(Pajaros.alas)		
    
                            -> Sirven para asegurarnos en ciertos métodos, que no modifique a ciertos objetos/instancias.
        @staticmethod
        def mirar():				-> () no lleva nada, ya que no se refieren ni a la clase ni a la instancia.
            #self.color = 'rojo'		-> No se puede acceder a los atributos de la instancia
            #cls.alas = 2			-> No se puede acceder a los atributos de la clase
    
            print("El pajaro mira")
            
    Pajaro.mirar()					-> EL pajaro mira			-> Se imprime ya que no requiere argumentos..
                                                -> Ni de clase ni de instancia
    
    --------------------------------------------------------        
    </pre>
    <br>
    <img src="img/6.1 Tipos de Métodos.png" alt="">
    <br>
    <p class="practica">Práctica</p>
    <pre>
        --------------------------------------------------------

        Práctica Tipos de Métodos 1
        Crea un método estático respirar() para la clase Mascota. Cuando se llame, debe imprimir en pantalla "Inhalar... Exhalar"
        
        class Mascota:
        
            @staticmethod
            def respirar():
                print("Inhalar..Exhalar")
        
        Mascota.respirar()		-> Inhalar..Exhalar
        
        --------------------------------------------------------
        
        Práctica Tipos de Métodos 2
        Crea un método de clase revivir() que actúa sobre el atributo de clase vivo de la clase Jugador, estableciéndolo en True cada vez que es invocado. El valor 
        
        predeterminado del atributo vivo, debe ser False.
        
        class Jugador:
            vivo = False
            
            @classmethod
            def revivir(cls):
                cls.vivo = True
        
        --------------------------------------------------------
        
        class Personaje:
            def __init__(self, cantidad_flechas):
                self.cantidad_flechas = cantidad_flechas
                
            def lanzar_flecha(self):
                self.cantidad_flechas = self.cantidad_flechas-1
        
        
        --------------------------------------------------------        
    </pre>
    <div class="context">
        <a href="#arriba">Arriba</a>
    </div>
    <p id="7">7. Herencia</p>
    <pre>
        Para crear una clase Hija, que herede de una clase Padre.. [atributo x][metodo y]
        Compartiendo sus atributos y metodos.
        
        Además la clase Hija puede sobreescribir los atributos de la clase Padre.
        O incluso definir algunos nuevos.
        
        Ejemplo..
        
        class Animal:
            pass
        
        class Pajaro(Animal):
            pass
        
        *Útil para el momento en el cual tenemos diversas clases que comparten un conjunto de características iniciales.
        Ej..
        
        class Animal:				------|
            def nacer(self):		      |
            def morir(self):		      |		
            def respirar(self):		      |
                                  |Don`t
        class Pajaro(Animal):			      |
            [codigo]			      |Repeat	-> DRY	De esta manera evitamos el "no te repitas"
                                  |			De manera innecesaria.
        class Mamifero(Animal):			      |Yoursel		Entre más código duplicado exista, más complicado será modificarlo..
            [codigo]			      |			Siengo más viable las contradicciones.
                                  |
        class Insecto(Animal):		              |
            [codigo]			------|
        
        
        --------------------------------------------------------
            Encontrar las Abstracciones en conjunto de los diversos Objetos es propia del Desarrollador.
        
        class Animal:
            pass
        
        class Pajaro(Animal):
            pass
        
        print(Pajaro.__bases__)			-> (<class '__main__.Animal'>,)	-> Hereda de la clas Animal
        
        print(Animal.__subclasses__())		-> (<class '__main__.Pajaro'>,)	-> Le hereda a Pajaro	
        
        --------------------------------------------------------
                *Por lo cual, al modificar la clase Animal, afectarìa a todas los objetos que de él Dependan.
        class Animal:
            def nacer(self):
                print("Este animal ha nacido")		-> Este animal ha nacido
        
        class Pajaro(Animal):
            pass
        
        piolin = Pajaro()
        
        piolin.nacer()			-> Metodo que hereda Pajaro de Animal
                        
        
        --------------------------------------------------------
        
        class Animal:
        
            def __init__(self, edad, color):
                self.edad = edad
                self.color = color
            
            def nacer(self):
                print("Este animal ha nacido")
        
        
        class Pajaro(Animal):
            pass
        
        
        
        piolin = Pajaro(2, 'amarillo')
        
        print(piolin.color)			-> Amarillo, es decir, obtenemos desde el objeto lo heredado a través del método del Animal.	
        
        --------------------------------------------------------        
    </pre>
    <br>
    <img src="img/7.1 Herencia.png" alt="">
    <br>
    <p class="practica">Práctica</p>
    <pre>
        --------------------------------------------------------
        Práctica Herencia 1
        Crea una clase llamada Persona, que tenga los siguientes atributos de instancia: nombre, edad. Crea otra clase, Alumno, que herede de la primera estos 
        
        atributos.
        
        class Persona:
            def __init__(self, nombre, edad):
                self.nombre = nombre
                self.edad = edad
        
        class Alumno(Persona):
            pass
        
        
        
        alumno1 = Alumno('Juan', 20)
        
        print(alumno1.nombre)			-> Juan
        
        --------------------------------------------------------
        Práctica Herencia 2
        Crea una clase llamada Mascota, que tenga los siguientes atributos de instancia: edad, nombre, cantidad_patas. Crea otra clase, Perro, que herede de la primera 
        
        sus atributos
        
        class Mascota:
            def __init__(self, edad, nombre, cantidad_patas)	
                self.edad = edad
                self.nombre = nombre
                self.cantidad_patas = cantidad_patas
        
        class Perro(Mascota):
            pass
        
        perro1 = Perro(12, 'Hermes', 4)
        
        print(perro1.edad)			-> 12
        
        --------------------------------------------------------
        Práctica Herencia 3
        Crea una clase llamada Vehiculo, que contenga los métodos acelerar() y frenar() (puedes dejar el código de los métodos en blanco con pass). Crea una clase 
        
        llamada Automovil que herede estos métodos de Vehiculo.
        
        class Vehiculo:
            def acelerar(self):
                pass
            def frenar(self):
                pass
            
        class Automovil(Vehiculo):
            pass
        
        --------------------------------------------------------        
    </pre>
    <div class="context">
        <a href="#arriba">Arriba</a>
    </div>
    <p id="8">8. Herencia Extendida</p>
    <pre>
        Ejemplo..
        Class Padre:
            def metodo1(self):
                [codigo]
        
        class Hija(Padre):
            - métodos heredados
            - métodos heredados y modificados
            - métodos nuevos			
        
        *Una clase puede heredar propiedades de muchas clases al mismo tiempo..
        *Ademàs las clases pueden Heredar varias clases hacia abajo.
        
        --------------------------------------------------------
        
        class Animal:
        
            def __init__(self, edad, color):
                self.edad = edad
                self.color = color
        
            def nacer(self):
                print("Este Animal ha nacido")
        
            def hablar(self):
                print("Este animal emite un sonido")
        
        class Pajaro(Animal):
            def hablar(self):
                print("pio")
        
            def volar(self, metros):
                print(f"El pajaro vuela {metros} metros")
        
        piolin = Pajaro(3, 'amarillo')
        
        piolin.nacer()			-> Este Animal ha nacido. 	-> Método Heredado.
        
        piolin.hablar()			-> Pio			-> Es decir, hereda pero nosotros lo sobreescribimos.
        
        pilin.volar(100)		-> Métodos nuevos en el hijo, que no existen en el padre.
        
        
        
        *Esto respecto a los métodos ahora vamos por los atributos.
        Los pájaros podrían tener atributos propios que no se encuentran en Animales.
        --------------------------------------------------------
        
        class Animal:
        
            def __init__(self, edad, color):
                self.edad = edad
                self.color = color
        
            def nacer(self):
                print("Este Animal ha nacido")
        
            def hablar(self):
                print("Este animal emite un sonido")
        
        class Pajaro(Animal):
        
            def __init__(self, edad, color, altura_vuelo):	
                self.edad = edad
                self.color = color				-> Esta es una manera de hacerlo.
                self.altura_vuelo = altura_vuelo
        
            def hablar(self):
                print("pio")
        
            def volar(self, metros):
                print(f"El pajaro vuela {metros} metros")
        
        piolin = Pajaro(3, 'Amarillo', 60)	-> Si tiene la altura de vuelo, una propiedad sumada dentro de sus caracterìsticas.
        mi_animal = Animal(5, 'Negro')	
        
        piolin.volar(100)			-> Si para la instancia Pajaro.
        mi_animal				-> No tiene volar
        --------------------------------------------------------
        
        class Animal:
        
            def __init__(self, edad, color):
                self.edad = edad
                self.color = color
        
            def nacer(self):
                print("Este Animal ha nacido")
        
            def hablar(self):
                print("Este animal emite un sonido")
        
        class Pajaro(Animal):
        
            def __init__(self, edad, color, altura_vuelo):	
                super().__init__(edad, color)			-> Esta es otra manera, util si hay muchos parámetros.
                self.altura_vuelo = altura_vuelo
        
            def hablar(self):
                print("pio")
        
            def volar(self, metros):
                print(f"El pajaro vuela {metros} metros")
        
        piolin = Pajaro(3, 'Amarillo', 60)	
        mi_animal = Animal(5, 'Negro')	
        
        piolin.volar(100)			
        
        --------------------------------------------------------
        
        class Padre:
            def hablar(self):
                print("Hola")
        
        
        class Hijo(Padre):
            pass
        
        
        class Nieto(Hijo):
            pass
        
        
        mi_nieto = Nieto()
        
        
        mi_nieto.hablar()		-> Hola		-> Es decir lo hereda a través de Hijo 
        
        --------------------------------------------------------
                    -> Herencias múltiples
        
        class Padre:
            def hablar(self):
                print("Hola")
        
        class Madre:
            def reir(self):
                print("ja, ja")
        
        class Hijo(Padre, Madre):
            pass
        
        
        class Nieto(Hijo):
            pass
        
        
        mi_nieto = Nieto()
        
        
        mi_nieto.reirr()		-> Ja, ja		-> Al heredar de Hijo, hijo tiene lo de madre y padre.
        mi_nieto.hablar()		-> hola			-> También el de padre.
        
        --------------------------------------------------------
        
                    -> Herencias múltiples
        
        class Padre:
            def hablar(self):
                print("Hola")
        
        class Madre:
            def reir(self):
                print("ja, ja")
        
            def hablar(self):			-> Pese a que comparte con Padre el mismo método.. 
                print('que tal')	
        
                                -> Prevalece el del Primero, debido al HIjo
        class Hijo(Padre, Madre):			-> Si acá es al revés, varia (Madre, Padre)	-> que tal
            pass
        
        
        class Nieto(Hijo):
            pass
        
        
        mi_nieto = Nieto()
        
        
        mi_nieto.hablar()		-> Hola		-> Toma el metodo hablar del padre, no del de la madre.
        
        --------------------------------------------------------
        
                -> Herencias múltiples, cambiando el orden, primero madre, luego padre, a través del Hijo
        
        class Padre:
            def hablar(self):
                print("Hola")
        
        class Madre:
            def reir(self):
                print("ja, ja")
        
            def hablar(self):			
                print('que tal')	
        
        
        class Hijo(Padre, Madre):			-> Orden invertido
            pass
        
        
        class Nieto(Hijo):
            pass
        
        
        mi_nieto = Nieto()
                        -> "mro" method order resolution, el orden en el cual se resuelve la herencia de los métodos
        print(nieto.__mro__)		-> Nieto	-> Hijo		-> Madre	-> Padre	-> Object, la clase "raíz", la que ordena todos los objetos.
                                        -> 1ª		-> 2ª
                        -> Muestra el orden.	
        
        *Por lo tanto, al usarlas, menos repetitivos, programas más compactos, màs faciles de mantener, lògicos.
        --------------------------------------------------------        
    </pre>
    <br>
    <img src="img/8.1 Herencia Extendida.png" alt="">
    <br>
    <p class="practica">Práctica</p>
    <pre>
        --------------------------------------------------------

        Práctica Herencia Extendida 1
        Si la clase Hija ha heredado de su padre la forma de reir, y de su madre la vocación, y hoy tienen el mismo trabajo en la Fiscalía, crea la herencia múltiple 
        
        que le permita a esta clase heredar correctamente de Padre y Madre.
        
        class Padre:
            def vocación(self):
                print("Trabajando en el Hospital")
        
            def reir(self):
                print("JA!")
            
        class Madre:
            def vocación(self):
                print("Fiscalía")
        
        class Hija(Madre, Padre):			-> Primero hereda de Madre, el metodo vocación.
            pass
        
        
        --------------------------------------------------------
        Práctica Herencia Extendida 2
        "El ornitorrinco es una de las criaturas más raras del mundo: aunque es un mamífero, pone huevos; y amamanta a sus crías pero no tienen mamas." (National 
        
        Geographic)
        
        Crea una clase Ornitorrinco que herede de otras clases: Vertebrado, Pez, Reptil, Ave y Mamifero, tal que "construyas" un animal que tiene los siguientes 
        
        métodos y atributos:
        
        - poner_huevos()
        
        - tiene_pico = True
        
        - vertebrado = True
        
        - venenoso = True
        
        - nadar()
        
        - caminar()
        
        - amamantar()
        
        
        class Vertebrado:
            vertebrado = True
        
        class Ave(Vertebrado):
            tiene_pico = True
            def poner_huevos(self):
                print("Poniendo huevos")
        
        class Reptil(Vertebrado):
            venesoso = True	
            
        class Pez(Vertebrado):
            def nadar(self):
                print("Nadando")
            def poner_huevos(self):
                print("Poniendo Huevos")
            
        class Mamífero(Vertebrado):
            def caminar(self):
                print("Caminando")	
            def amamantar(self):
                print("Amamantando crìas")
        
        class ornitorrinco(Mamífero, Pez, Reptil, Ave):
            pass
        
        
        
        
        --------------------------------------------------------
        Práctica Herencia Extendida 3
        Un hijo ha heredado de su padre todas sus características, sin embargo, tienen diferentes hobbies. Logra que la clase Hijo herede de Padre todos sus métodos y 
        
        atributos, sobreescribiendo el método hobby() para que se devuelva[1]: "Juego videojuegos en mi tiempo libre"
        
        class Padre():
            color_ojos = "marrón"
            tipo_pelo = "rulos"
            altura = "media"
            voz = "grave"
            deporte_preferido = "tenis"
            def reir(self):
                return "Jajaja"
            def hobby(self):
                return "Pinto madera en mi tiempo libre"
            def caminar(self):
                return "Caminando con pasos largos y rápidos"
            
        class Hijo(Padre):
            def hobby(self):
                return "Juego videojuegos en mi tiempo libre"
        
        
        --------------------------------------------------------        
    </pre>
    <div class="context">
        <a href="#arriba">Arriba</a>
    </div>
    <p id="9">9. Polimorfismo</p>
    <pre>
        Segundo Pilar de la Programación Orientada a Objetos. 	
        Esto refiere a que los objetos pueden tomar diversas formas..
        
        Cuando diveros objetos instanciados desde una clase, pueden compartir un mismo método.
        
        --------------------------------------------------------
        
        class Vaca:
        
            def __init__(self, nombre):
                self.nombre = nombre
        
            def hablar(self):
                print(self.nombre + " dice muu")
        
        class Oveja:
        
            def __init__(self, nombre):
                self.nombre = nombre
        
            def hablar(self):
                print(self.nombre + " dice bee")
        
        
        vaca1 = Vaca('Aurora')
        oveja1 = Oveja('Nube')
        
        vaca1.hablar()				-> Es decir, distintos objetos que comparte un mismo mètodo, pero cada mètodo tiene su particularidad.			
        oveja1.hablar()
        
        
        --------------------------------------------------------
        
        class Vaca:
        
            def __init__(self, nombre):
                self.nombre = nombre
        
            def hablar(self):
                print(self.nombre + " dice muu")
        
        class Oveja:
        
            def __init__(self, nombre):
                self.nombre = nombre
        
            def hablar(self):
                print(self.nombre + " dice bee")
        
        
        vaca1 = Vaca('Aurora')								-> Observando el Loop
        oveja1 = Oveja('Nube')
        
        animales = [vaca1, oveja1]		-> Es decir la lista tiene objetos distintos, cada uno de ellos tiene un mètodo que se llama igual
                            -> Y lo que permite el poliformismo es realizar un iteraciòn, llamando cada objeto de manera distinta..
        for animal in animales:			-> Haciendole ejecutar el mètodo que se llaman igual, pero que hacen cosas distintas.
            animal.hablar() 
        
        
        --------------------------------------------------------
        
        class Vaca:
        
            def __init__(self, nombre):
                self.nombre = nombre
        
            def hablar(self):
                print(self.nombre + " dice muu")
        
        class Oveja:
        
            def __init__(self, nombre):
                self.nombre = nombre
        
            def hablar(self):
                print(self.nombre + " dice bee")
        
        
        vaca1 = Vaca('Aurora')
        oveja1 = Oveja('Nube')	
        
        def animal_habla(animal):		-> El animal que pasamos como parámetro, sin importar su forma, puede ejecutar objetos que tengan el mismo nombre.
            animal.hablar()			-> Son clases distintas, vaca y oveja, tienen muchisimas diferencias pero comparten el MÈTODO.	
                            
        animal_habla(vaca1)
        animal_habla(oveja1)
        
        
        *De esta manera el polimorfimos permite:
        -Iterar a travès de objetos de diversas formas.
        -Para llamar objetos que tengan el mismo nombre.
        -Tambièn podemos crear funciones que ejecuten esos mètodos diferentes sin importar que tipo de objeto le vamos a pasar.
        
        --------------------------------------------------------        
    </pre>
    <br>
    <img src="img/9.1 Polimorfismo.png" alt="">
    <br>
    <p class="practica">Práctica</p>
    <pre>
        --------------------------------------------------------

        Práctica Polimorfismo 1
        La función incorporada en Python len() tiene un comportamiento polimórfico, ya que calcula el largo de un objeto en función de su tipo (strings, listas, 
        
        tuples, entre otros), devolviendo la cantidad de items o caracteres que lo componen.
        
        Crea un iterador que recorra los siguientes objetos: palabra, lista, tupla y muestre en pantalla (print()) para cada uno de ellos su longitud con la función 
        
        len().
        
        Puedes recordar cómo implementar la función len() siguiente enlace: https://docs.aws.amazon.com/es_es/redshift/latest/dg/r_LEN.html
        
        
        palabra = "polimorfismo"
        lista = ["Clases", "POO", "Polimorfismo"]
        tupla = (1, 2, 3, 80)
        
        for dato in [palabra, lista, tupla]:
            print(len(dato))
        
        --------------------------------------------------------
        
        Práctica Polimorfismo 2
        Cuentas con tres clases de personajes en un juego, los cuales cuentan con sus métodos de ataque específicos.
        
        Crea un iterador que logre un ataque conjugado en el siguiente orden: Arquero, Mago, Samurai, llamando al método atacar() de cada uno de los personajes. 
        
        Deberás crear instancias de cada una de las clases anteriores para construir un iterable (una lista llamada personajes) que pueda recorrese en dicho orden.
        
        class Mago():
            def atacar(self):
                print("Ataque mágico")
        
        class Arquero():
            def atacar(self):
                print("Lanzamiento de flecha")
        
        class Samurai():
            def atacar(self):
                print("Ataque con katana")
                
        gandalf = Mago()
        hawkeye = Arquero()
        jack = Samurai()
        
        personajes = [hawkeye, gandalf, jack]
        
        for personaje in personajes:
            personaje.atacar()
        
        
        --------------------------------------------------------
        
        Práctica Polimorfismo 3
        Tienes tres clases de personajes en un juego, los cuales cuentan con sus métodos de defensa específicos.
        
        Crea una función llamada personaje_defender(), que pueda recibir un objeto (una instancia de las clases de tus personajes), y ejecutar su método defender() 
        
        independientemente de qué tipo de personaje se trate.
        
        class Mago():
            def defender(self):
                print("Escudo mágico")
        
        class Arquero():
            def defender(self):
                print("Esconderse")
        
        class Samurai():
            def defender(self):
                print("Bloqueo")
        
        def personaje_defender(personaje):
            personaje.defender()
        
        --------------------------------------------------------
        En este día has aprendido qué es la Programación Orientada a Objetos, y también hemos entendido que este modo de programación está basado en 6 pilares 
        
        fundamentales.
        
        Ya has aprendido 2 de esos pilares, a través de las lecciones de video, las notas descargables y los ejercicios de práctica. Estos son:
        
        Herencia
        
        Polimorfismo
        
        Para aprender los 4 pilares restantes (que son más bien conceptuales), he preparado para ti 4 artículos especiales que de seguro te ayudarán a comprenderlos 
        
        con facilidad:
        
        Cohesión			-><a href="https://escueladirecta-blog.blogspot.com/2021/09/cohesion-pilares-de-la-programacion.html">Ver</a>
        
        Acoplamiento			-> <a href="https://escueladirecta-blog.blogspot.com/2021/10/acoplamiento-pilares-de-la-programacion.html">Ver</a>
        
        Abstracción			-> <a href="https://escueladirecta-blog.blogspot.com/2021/10/abstraccion-pilares-de-la-programacion.html">Ver</a>
        
        Encapsulamiento			->  <a href="https://escueladirecta-blog.blogspot.com/2021/10/encapsulamiento-pilares-de-la.html"> Ver</a>
        
        
        https://escueladirecta-blog.blogspot.com/
        --------------------------------------------------------        
    </pre>
    <p id="10">10. Métodos Especiales</p>
    <pre>
        Mètodos Màgicos -> __nombre__

        __init__ Para iniciar los atributos de una clase nueva
        __mro__ Para Ver el orden en que se organizan la bùsqueda de metodos heredados
        __bases__   
        __subclasses__
        
        --------------------------------------------------------
        
        mi_lista = [1,1,1,1,1,1,1]
        print(len(mi_lista))		-> 7
        
        
        class Objeto:
            pass
        
        mi_objeto = Objeto()
        print(len(mi_objeto))		->Error, no tiene len
        
        print(mi_objeto)		-> Vemos la representaciòn del Objeto
        
        --------------------------------------------------------
        
        class CD:
        
            def __init__(self, autor, titulo, canciones):
                self.autor = autor
                self.titulo = titulo
                self.canciones = canciones
        
        mi_cd = CD('Pink Floyd', 'The Wall', 24)
        
        
        print(mi_cd)			-> Vemos la representaciòn del Objeto
        print(str(mi_cd))		-> Vemos la representaciòn del Objeto, igual
        
        --------------------------------------------------------
        
        class CD:
        
            def __init__(self, autor, titulo, canciones):
                self.autor = autor
                self.titulo = titulo
                self.canciones = canciones
        
            def __str__(self):							-> De esta manera modificamos el mètodo str, elegimos que mostrar. 
                return f"Album: {self.titulo} de {self.autor}."
        
        
        mi_cd = CD('Pink Floyd', 'The Wall', 24)
        
        print(mi_cd)		-> Album: The Wall de Pink Floyd.
        
        --------------------------------------------------------
        
        class CD:
        
            def __init__(self, autor, titulo, canciones):
                self.autor = autor
                self.titulo = titulo
                self.canciones = canciones
        
            def __str__(self):							
                return f"Album: {self.titulo} de {self.autor}."
        
            def __len__(self):
                return self.canciones			-> Establecemos que la cantidad de canciones serà el largo con len
        
        mi_cd = CD('Pink Floyd', 'The Wall', 24)
        
        print(len(mi_cd))					-> 24
        
        --------------------------------------------------------
        
        class CD:
        
            def __init__(self, autor, titulo, canciones):
                self.autor = autor
                self.titulo = titulo
                self.canciones = canciones
        
            def __str__(self):							
                return f"Album: {self.titulo} de {self.autor}."
        
            def __len__(self):
                return self.canciones			
        
            def __del__(self):
                print("Se ha eliminado el cd")		-> Ahora avisarà, al modificar el mètodo.
        
        mi_cd = CD('Pink Floyd', 'The Wall', 24)
        
        del mi_cd					-> Elimina el objeto, no da una retroalimentaciòn, pero, podemos modificarlo..
        
        
        --------------------------------------------------------
        
        Considerar ademàs que los objetos tienen muchisimos Mètodos.
        
        --------------------------------------------------------
    </pre>
    <br>
    <img src="img/10.1 Métodos Especiales.png" alt="">
    <br>
    <p class="practica">Práctica</p>
    <pre>
        --------------------------------------------------------

        Práctica Métodos Especiales 1
        Dada la clase Libro, implementa el método especial __str__ para que cada vez que se imprima el objeto, devuelva '"{titulo}", de {autor}' (atención: el título 

        debe estar encerrado entre comillas dobles).

        class Libro():
            def __init__(self, titulo, autor, cantidad_paginas):
                self.titulo = titulo
                self.autor = autor
                self.cantidad_paginas = cantidad_paginas

            def __str__(self):
                return f'"{self.titulo}", de {self.autor}'

        --------------------------------------------------------

        Práctica Métodos Especiales 2
        Dada la clase Libro, implementa el método especial __len__ para que cada vez que se ejecute la función len() sobre el mismo, devuelva el número de páginas como 

        número entero.

        class Libro():
            def __init__(self, titulo, autor, cantidad_paginas):
                self.titulo = titulo
                self.autor = autor
                self.cantidad_paginas = cantidad_paginas

            def __len__(self):
                return self.cantidad_paginas

        --------------------------------------------------------

        Práctica Métodos Especiales 3
        Dada la clase Libro, implementa el método especial __del__ para que el usuario sea informado con el mensaje "Libro eliminado", mostrándolo en pantalla cada vez 

        que el libro se elimine.

        class Libro():
            def __init__(self, titulo, autor, cantidad_paginas):
                self.titulo = titulo
                self.autor = autor
                self.cantidad_paginas = cantidad_paginas

            def __del__(self):
                print(f'Libro eliminado')

        --------------------------------------------------------        
    </pre>
    <br>
    <div class="context">
        <a href="#arriba">Arriba</a>
    </div>
    <br>
    <br>
    <p id="11">11. Proyecto del Día 7</p>
    <pre>
        Realizar operaciones en su cuenta bancaria.. En funciòn de POO.

        clase Persona
            - Atributos: nombre y apellido
        
        clase Cliente (Persona)					-> Hereda de Persona, tendrà ademàs atributos propios. 
            - Atributos: numero_cuenta y balance
            - Méotdos: 	1 Para imprimir, con los datos del cliente, incluyendo el balance de la cuenta.
                    2 depositar(), cuanto dinero agregar a la cuenta. 
                    3 retirar()	
        
        Con las dos clases creadas.. 					-> El usuario puede hacer todas las operaciones que desee hasta que quiera salir.
        Vmos al codigo para elegir Depositar, Retirar o Salir.		-> El programa debe llevar la cuenta, cuanto dinero hay en el balance.
                                        -> Que no retire màs dinero del que posee.
        
        Sabiendo clases y objetos..
        No es necesario crear funciones que devuelvan el balance.
        Ya que la instancia de cliente puede saber constantemente que balance tendrà, haciendo las operaciones llamando directamente al atributo, y no una variable 
        
        separada.
        
        
        Recomendación.. Luego de crear las 2 clases.
            funciones crear_cliente() 	-> Pidiendo toda la info necesaria, devolviendo a travès de return un objeto cliente ya creado.
                  inicio()		-> Ejecuta todo el còdigo, llama a la función crear cliente y mantiene al usuario en loop..
                            Si quiere retirar, depositar o salir del programa. Mostrando el balance cuando haga la modificaciòn.
        
        Confiar que el usuario ingresarà las opciones correctar, sin validar tanto en el còdigo.
        --------------------------------------------------------        
    </pre>
    <br>
    <div class="context">
        <a href="#arriba">Arriba</a>
    </div>
    <br>
    <br>
    <p id="12">12. Solución al Proyecto del Día 7</p>
    <p class="practica">Práctica</p>
    <pre>
        --------------------------------------------------------
        class Persona:
        
            def __init__(self, nombre, apellido):
                self.nombre = nombre
                self.apellido = apellido
        
        
        class Cliente(Persona):
            def __init__(self, nombre, apellido, numero_cuenta, balance = 0):
                super().__init__(nombre, apellido)
                self.numero_cuenta = numero_cuenta
                self.balance = balance
        
            def __str__(self):
                return f"Cliente: {self.nombre} {self.apellido}\nBalance de cuenta {self.numero_cuenta}: ${self.balance}"
        
            def depositar(self, monto_deposito):
                self.balance += monto_deposito
                print("Deposito aceptado")
        
            def retirar(self, monto_retiro):
                if self.balance >= monto_retiro:
                    self.balance -= monto_retiro
                    print("Retiro realizado")
                else:
                    print("Fondos insuficientes")
        
        
        def crear_cliente():
            nombre_cl = input("Ingrese su nombre: ")
            apellido_cl = input("Ingrese su apellido: ")
            numero_cuenta = input("Ingrese su numero de cuenta: ")
            cliente = Cliente(nombre_cl, apellido_cl, numero_cuenta)
            return cliente
        
        
        def inicio():
            mi_cliente = crear_cliente()
            print(mi_cliente)
            opcion = 0
        
            while opcion != 'S':
                print('Elije: Depositar (D), Retirar (R), o Salir (S)')
                opcion = input()
        
                if opcion == 'D':
                    monto_dep = int(input("Monto a depositar: "))
                    mi_cliente.depositar(monto_dep)
                elif opcion == 'R':
                    monto_ret = int(input("Monto a retirar: "))
                    mi_cliente.retirar(monto_ret)
                print(mi_cliente)
        
            print("Gracias por operar en Banco Python")
        
        
        inicio()        
    </pre>
    <br>
    <div class="context">
        <a href="#arriba">Arriba</a>
    </div>
    <br>
    <br>

    
    <div class="context">
        <a href="../6/index.html">Volver</a>
        <a href="../../index.html">Inicio</a>
        <a href="../8/index.html">Siguiente</a>
    </div>

    <script src="js/01.js"></script>

</body>
</html>